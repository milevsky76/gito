# #Типы конфигурации Git
* Локальная `.git\config`
* Глобальная `\Users\USERNAME\.gitconfig`
* Системная `\Program Files\Git\etc\gitconfig`
## Опции команды git config
* --local `git config example` или `git config --local example`
* --global `git config --global example`
* --system `git config --system example`
## Задаём имя пользователя
`git config --global user.name "Ваше имя или никнейм"`
## Задаём электронную почту пользователя
`git config --global user.email "Ваша почта"`
## Задаём параметр отвечающий за окончания строк
`git config --system core.safecrlf warn`

Eсли что-то пойдёт не так во время подготовки к замене CRLF на LF
* `true` Git отменит операцию, если не будет возможности откатить изменения назад из LF в CRLF
* `warn` Git выдаст предупреждение, но не отменит операцию
## Задаём параметр исправляющий вывод кириллицы
`git config --system core.quotepath off`

Исправление вывода кириллицы после использования команды `git status`
## Просматриваем заданные параметры с помощью команды git config
Чтобы просмотреть глобальный конфигурационный файл `git config --list --global`

* `--global` — позволяет обратиться к глобальной конфигурации
* `--list` — выводит список всех параметров из конфигурационного файла

Есть опция `--show-origin`, которая выводит дополнительно путь до конфигурационного файла  
`git config --list --global --show-origin`

Зачастую команду используют без указания конфигурационного файла `git config --list --show-origin`

# #Работа с локальным и удалённым репозиторием
## Работа с локальным репозиторием 
`git init` — инициализация репозитория

## Клонируем удалённый репозиторий
Скопируем ссылку из вкладки HTTPS удалённого репозитория `https://github.com/NAMEUSER/NAMEREPO.git`  
Далее откроем Git Bash на локальном устройстве в любом месте  
`git clone https://github.com/USERNAME/REPONAME.git`

## Связывание локального и удалённого репозитория 
В созданной директории, в которой инициализировали локальный репозиторий, пропишем  
`git remote add origin https://github.com/USERNAME/REPONAME.git`  
Команда добавляет удалённый репозиторий с названием(может быть любым) `origin` (не является названием удалённого репозитория, это локальный псевдоним, который можно использовать вместо `URL-адреса` удалённого репозитория)
## Проверяем, добавился ли удалённый репозиторий
* `git remote` — список всех доступных локальных псевдонимов удалённых репозиториев
* `git remote get-url origin` — URL-адрес удалённого репозитория `origin`
* `git remote -v` — две предыдущие команды (справа в скобках указано, для какой команды распространяется данный локальный псевдоним и URL-адрес)

## Добавляем ещё один удалённый репозиторий
Можно создавать любое количество удалённых репозиториев `git remote add NAME url-адрес`

Используем `origin` при этом отправляем изменения в разные удалённые репозитории  
`git remote set-url --add origin url-адрес`

## Удаляем связь между локальным и удалённым репозиторием
Удаляем связь с определённым репозиторием  
`git remote remove NAME` — удаляем локальный псевдоним `NAME` и связь с удалённым репозиторием

Удалим данный репозиторий из `origin` используем команду `git remote set-url --delete origin url-адрес`

## Обновляем URL-адрес удалённого репозитория
На месте `url-адрес` нужно указать новый URL-адрес  
`git remote set-url origin url-адрес`

## Переименовываем локальный псевдоним
`git remote rename origin NAME`

## Проверяем файлы в локальном репозитории
`git status` — проверка статуса файла  
Опция `--short` или `-s` — выводит информацию о статусах файлов в укороченном формате(`??` означают статус `untracked`)

## Добавляем определённые файлы в индекс
Изменения в индекс добавляются с помощью команды `git add`

`git add NAMEFILE` — добавление одного файла `NAMEFILE`

## Добавляем все файлы в индекс относительно текущей директории
* `git add .` — добавление всех файлов относительно `текущей` директории
* `git add --no-all .` — реализует старое поведение команды(добавление в индекс только изменённых и новых файлов, а удалённые не добавлять) аналог опции `--no-all`, `--ignore-removal`
* `git add :/` — добавление всех файлов в индекс

У `git add :/` есть аналоги `git add -A` (более развёрнуто `git add --all`) и `git add --no-ignore-removal`
точно так же добавляют все файлы в индекс, опция `--no-ignore-removal` означает, что не нужно игнорировать удалённые файлы

* `git add NAMEDIR/` — добавление всех файлов только определённой директории в индекс

## Записываем индексированные изменения
Чтобы зафиксировать изменения, используем команду `git commit -m "текст коммита"`, опция `-m` позволяет ввести текст коммита

## Выводим список коммитов
* `git log` — вывод списка коммитов
* `git log --oneline` — выводит хэш в укороченном формате, ветку, в которой был сделан коммит, а также текст коммита
* `git log --stat` —  выводит список коммитов, а также статистику по изменённым файлам (какие файлы были изменены и количество изменённых строк)
* `git log --shortstat` — уменьшенная версия опции `--stat`, выводит только общее количество изменённых файлов и количество изменённых строк
* `git log --name-only` — выводит то же самое, что и `git log`, а также дополнительно список изменённых файлов
* `git log --name-status` — улучшенная версия `--name-only`, выводит названия изменённых файлов и статус, который у них был на момент коммита (позволяет отследить, какие файлы были добавлены или удалены)
* `git log --abbrev-commit` — выводит то же самое, что и `git log`, но вместо длинного хэша будет короткий, как при использовании опции `--oneline`
* `git log --relative-date` — выводит то же самое, что и `git log`, только показывает дату в относительном формате (3 hours ago)
* `git log -p` — выводит то же самое, что и `git log`, и ещё показывает, какие конкретно изменения были сделаны в каждом коммите
* `git log -1` — цифра указывает, какое количество последних коммитов нужно отобразить
* `git log --author=имя-автора` — позволяет вывести коммиты от определённого автора
* `git log --graph` — выводит то же самое, что и `git log`, и ещё показывает ASCII-граф (в котором отображается история ветвлений и слияний)
* `git log --reverse` — позволяет вывести коммиты в обратном хронологическом порядке (сначала старые, а потом новые)
* `git log --after=дата` — выводит коммиты, которые были сделаны после определённой даты, аналог — опция `--since=дата`
* `git log --before=дата` — выводит коммиты, которые были сделаны до определённой даты
* `git log --no-decorate` — выводит коммиты и убирает названия веток, на которых присутствуют коммиты, а также указатели

## Отправляем изменения в удалённый репозиторий
Для первой отправки изменений `git push --set-upstream origin main`  
чаще используют сокращённую версию `git push -u origin main`

`git push` — отправить изменения в удалённый репозиторий  
опция `--force` или `-f`, которая принудительно отправляет изменения в удалённый репозиторий, игнорируя многие предупреждения и ошибки

`git push --all` — отправляет изменения со всех существующих веток

## Добавляем выборочно изменения в индекс
`git add -p` (развёрнуто `--patch`) — выбрать изменения в файле

## Обновляем статус отслеживаемых файлов
`git add -u` (развёрнуто `--update`) — обновляет статус отслеживаемых файлов, изменённых и удалённых, у файлов со статусом `untracked` статус не будет обновлён

## Пропускаем этап добавления файлов в индекс
Работает только с отслеживаемыми файлами, то есть для файлов, которые имеют статус `untracked` команда работать не будет

`git commit -a` (развёрнуто `--all`) — сначала добавляет изменения в индекс, а потом фиксирует их

`git commit -a -m "текст коммита"` или `git commit -am "текст коммита"`

## Добавляем изменения в уже созданный последний коммит
Когда добавим новые изменения в последний коммит, то хэш этого коммита изменится, поэтому манипуляцию нужно производить до того, как отправим коммит в удалённый репозиторий

Если нужно отредактировать последний коммит `git commit --amend -m "новый текст последнего коммита"`  
Если не нужно редактировать текст последнего коммита `git commit --amend --no-edit`

Перед этим добавим изменения в индекс с помощью `git add -A`

## Затягиваем изменения в локальный репозиторий
`git pull` — затягивания изменений с удалённого репозитория  
`git pull origin NAMEBRANCH` — затягивания изменений с определённой ветки (с добавлением локального псевдонима и названия ветки)

# #Работа с ветками

## Меняем название ветки по умолчанию
`git config --system init.defaultBranch master`

## Создаём новую ветку
* `git branch название-ветки` — создать новую ветку
* `git checkout -b название-ветки` — создать новую ветку и сразу на неё переключиться
* `git switch --create develop` — создать новую ветку и сразу на неё переключиться(новый способ, аналоги `--create` и `-c`)

## Переключаемся между ветками
* `git checkout название-ветки`
* `git switch название-ветки`
* `git switch -` — переключиться только на предыдущую ветку

## Просматриваем существующие ветки
* `git branch` — посмотреть только локальные ветки
* `git branch -l` (развёрнуто `--list`) — показать только локальные ветки
* `git branch -l "task-*"` — показать те ветки, которые начинаются с `task-`
* `git branch -r` (развёрнуто `--remotes`) — посмотреть все удалённые ветки
* `git branch -a` (развёрнуто `--all`) — посмотреть все ветки сразу, и локальные, и удалённые

## Переименовываем ветку
* `git branch -m старое-название-ветки новое-название-ветки` — находясь на любой ветке
* `git branch -m новое-название-ветки` — находясь на ветке, котой меняем название

## Переключаемся на удалённую ветку
* `git checkout название-ветки`
* `git switch --detach название-ветки`  
`--detach` отвечает за переход в состояние `detached HEAD`, в этом состоянии указатель `HEAD` ссылается на последний коммит, а не на ветку

## Удаляем ветку в локальном репозитории
`git branch -d название-ветки` (развёрнуто `--delete`) — удаляем не текущую ветку

`git branch -D название-ветки` — принудительно удаляет ветку  
`git branch -d -f название-ветки` или `git branch --delete --force название-ветки`

## Удаляем ветку в удалённом репозитории
`git push -d origin название-ветки` (развёрнуто `--delete`) — удаляем ветку в удалённом репозитории  
альтернатива `git push origin :название-ветки>` (более старый вариант)

## Объединяем ветки с использованием режима fast-forward
`git merge название-ветки` — прописывать в той ветке, в которую будем вливать другую ветку  
По умолчанию установлена опция `--ff`, которая отвечает за режим `fast-forward`

## Объединяем ветки с использованием режима no-fast-forward
`git merge --no-ff develop -m "текст коммита"`  
Если не использовать опцию `-m`, Git сам напишет название коммита  
Опция `--no-ff`, отвечает за режим `no-fast-forward`

## Сжимаем коммиты c помощью опции squash
`git merge название-ветки --squash` — переносятся лишь сделанные изменения, и сразу добавляются в индекс (нужен коммит)

## Решаем конфликт с помощью командной строки
* `git checkout --their NAMEFILE` — изменение, пришедшее с другой ветки
* `git checkout --ours NAMEFILE` — изменение, которое было на ветке

`git merge --continue` — продолжить слияние (создаётся коммит с текстом, который указывали при слиянии)  
если слияние проходит с использованием режима `fast-forward`, придётся вручную создавать коммит

## Перебазируем коммиты
`git rebase main` — перемещаем коммиты с ветки `main` в ветку `new`, на которой делали изменения (после создания ветки `new`, в `main` был сделан коммит)  
после перехода на `main` делаем `git merge new` (прошло слияние в режиме `fast-forward`)

## Сжимаем коммиты
Команды нужно выполнять только на тех коммитах, которые ещё не отправлены в удалённый репозиторий

`git rebase -i хэш-коммита` (развёрнуто `--interactive`) — в один коммит, сжимаются коммиты до указонного `хэш-коммита`

## Cherry-pick
`git cherry-pick хэш-коммита` — создаёт точную копию коммита или группы коммитов  
можно передавать не один хэш, а начальный и конечный `git cherry-pick начальный-хэш конечный-хэш`

* `--edit` (сокращённо `-e`) — позволяет изменить текст коммита
* `--no-commit` (сокращённо `-n`) — изменения будут просто перенесены и добавлены в индекс (после нужна фиксация коммита)
`git cherry-pick --no-commit хэш-коммита` аналог `git checkout хэш-коммита *`

`git cherry-pick --quit` — после решения конфликта можно сбросить запомненное состояние и остановить копирование коммитов (работает только для группы коммитов)

`git cherry-pick --continue` — продолжение создания копии коммита

## Совмещаем merge, rebase и cherry-pick
Опции для `git rebase`
* `--no-reapply-cherry-picks` — скопированный коммит будет сначала прочитан, затем удалён, и только после этого будет добавлен перебазированный коммит
* `--reapply-cherry-picks` — повторно применить скопированные коммиты и заменить старые хэши на новые

Как правило выполняются в такой последовательности cherry-pick, rebase и merge

# #Просмотр изменений
## Просматриваем незакоммиченные изменения в одном файле
`git diff NAMEFILE` — посмотреть незакоммиченные изменения в файле `NAMEFILE`

## Просматриваем незакоммиченные изменения во всех файлах
`git diff` — просмотреть незакоммиченные изменения во всех файлах

## Сравниваем коммиты и узнаём, какие изменения были сделаны в одном файле
`git diff хэш-коммита1 хэш-коммита2 NAMEFILE` — сравнение изменений коммита `хэш-коммита1` и коммита `хэш-коммита2` в файле `NAMEFILE`

## Сравниваем коммиты и узнаём, какие изменения сделаны во всех файлах
`git diff хэш-коммита1 хэш-коммита2`

`git diff 1ec1 195d --name-only` — посмотреть не сами изменения, а только названия изменённых файлов (опция `--name-only`)

## Сравниваем локальные ветки
`git diff название-ветки..main`  
`..` — позволяют указать диапазон коммитов (берём все доступные коммиты из ветки `main` и недоступные при этом из ветки `название-ветки`, а затем сравниваем их)

## Сравниваем локальную ветку с удалённой
`git diff название-ветки..origin/main`

## Сравниваем файлы вне репозитория
`git diff filename1.txt filename2.txt`

## Просматриваем последние закоммиченные изменения
`git show` — вывода изменений, сделанных в последнем коммите, на который показывает относительный указатель `HEAD`  
связка двух других команд `git log -1` и `git diff HEAD~1 HEAD~0`

`git show HEAD~2..HEAD~0 --oneline` — выбираем диапазон коммитов

## Просматриваем, кто и когда вносил изменения
`git blame NAMEFILE` — отображает кто и когда вносил изменения в файле `NAMEFILE`

Опции (`git blame NAMEFILE -L 2,10 -e`)
* `-L` — выводит информацию только о тех строках, которые укажете `-L 2,10`
* `-e` — выводит вместо имени пользователя его почту
